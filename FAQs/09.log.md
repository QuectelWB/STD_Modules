# 抓log

一些未知原因导致模组功能异常，需要抓取log。包括

	Modem log （又称QLog、QXDM log）
	Dump log
	Demsg log （Host AP侧，Host Driver log）
	tcpdump
	usb log （又称usbmon log）
	Android RIL log
	模组AP的AP kernel log（模组的debug port log）


多数情况下，涉及模块、注网、网络等情况的问题需要抓modem log，涉及工具、驱动有关的，还需要抓Host侧的dmesg log和usb log。


## Modem log

Windows和Linux/Android 分别使用不同的工具。

### Windows 

Windows OS 用QWinlog。

![](QWinlog.png)

将Quectel 模组连上Windows机器，Type选择USB Port, Port选择DM port，Bandrate选择默认的115200。Config file，对不同的场景和模组选择不同cfg文件。


LTE模组生成的目标文件的扩展名是bin,5G模组生成的目标文件是*.qmdl2，同时还有数据库文件扩展名为qdb。将所有的bin、qmdl2还有qdb文件一起打包发送给Quectel FAE

QXDM 也可以抓Modem log，但是QXDM需要Qualcomm License，不直接提供客户。FAE到客户现场，可以用QXDM直接抓取log。

### Linux

Linux系统，移远提供了抓包工具的源码，需要将该源码编译成可执行的二进制文件，在目标平台上运行。
gcc（或者arm-linux-gcc）版本较低时，Makefile中加上-lrt。
对Android系统，可以通过源码编译，也可以使用预先编译好的可执行文件，QLog的压缩包和RIL的压缩包中均有QAndroidLog。

QLog的使用

	root@q-K501LB:/home/q/Driver_Tools_Quectel/QLog# ./QLog --help
	[000.000] QLog Version: Quectel_QLog_Linux&Android_V1.5
	./QLog: invalid option -- '-'
	[000.000] Usage: ./QLog -p <log port> -s <log save dir> -f filter_cfg -n <log file max num> -b <log file size MBytes>
	[000.000] Default: ./QLog -p /dev/ttyUSB0 -s . -n 512 -b 128 to save log to local disk
	[000.000]     -p    The port to catch log (default '/dev/ttyUSB0')
	[000.000]     -s    Dir to save log, default is '.'
	[000.000]           if set as '9000', QLog will run in TCP Server Mode, and can be connected with 'QPST/QWinLog/CATStudio'!
	[000.000]     -f    filter cfg for catch log, can be found in directory 'conf'. if not set this arg, will use default filter conf
	[000.000]           and UC200T&EC200T do not need filter cfg.
	[000.000]     -n    max num of log file to save, range is '0~512'. default is 0. 0 means no limit.
	[000.000]           or QLog will auto delete oldtest log file if exceed max num
	[000.000]     -m    max size of single log file, unit is MBytes, range is '2~512', default is 128
	[000.000]     -q    Exit after usb disconnet
	[000.000]
	For example: ./QLog -s .

其中值得的关注的有
	
	-p 选择DM port, 用于选择多个Quectel模组之一抓log的情况；
	-s 选择log的保存位置，如果不加该选择，模组保存在当前位置；如果设置成9000，QLog工作在TCP Server 模组，log保存在远程TCP Client那（可以是QPST/QEWinLog），用于嵌入式系统存储空间不足，log过大的情况，下面会有详细操作介绍。
	-f 指定cfg文件，和QWinLog这方面功能相同，选择不同的cfg，抓取出来的log的内容、大小会有区别。

QLog 可以放在后台运行

	root@q-K501LB:/home/q/Driver_Tools_Quectel/QLog# ./QLog &
	[000.000] QLog Version: Quectel_QLog_Linux&Android_V1.5
	[000.000] will use filter file: default filter
	[000.101] Find [0] idVendor=2c7c, idProduct=0125, bNumInterfaces=6, ttyDM=/dev/ttyUSB0, busnum=001, dev=006, usbdevice_pah=/sys/bus/usb/devices/1-3
	[000.102] open /dev/ttyUSB0 ttyfd = 3
	[000.102] Press CTRL+C to stop catch log.
	[000.102] catch log via tty port
	[000.106] qlog_logfile_create qlog_files/20201117_111415_0000.qmdl logfd=4
	[000.510] qlog_init_filter_finished
	[005.273] recv: 0M 322K 68B  in 5171 msec
	[010.382] recv: 0M 415K 949B  in 5109 msec
	...


抓取到的log，包括qmdl2和，一起打包发送给Quectel。

### TCP抓发

嵌入式系统的rom空间较小，如果条件允许，客户可以通过接U盘等方式，将log保存在U盘等外部rom上。但是如果客户设备无法外接U盘/tf卡，但是该设备上有以太网接口或者无线接口，可以在该嵌入式平台上运行QLog，将log保存到局域网里的另外一台Windows OS的机器上。
结构如图所示


![](tty2tcp.png)


同时QWinLog配置成TCP Client,如下

![](Qwinlog_set_for_tty2tcp.png)


## Dump log

抓dump log，需要先配置模组的AP和modem不能出现故障的时候重启。执行AT指令

	at+qcfg="aprstlevel",0
	at+qcfg="modemrstlevel",0

在模组进dump状态后，会只有一个ttyUSB0保留

运行QLog

	./QLog -s dump


手动让模组dump的方法

- AT指令 at+qtest="dump",1 
- 硬件方法。咨询QuectelFAE


## Host Side dmesg log



## usb log

[Kernel Document](https://elixir.bootlin.com/linux/v5.10-rc4/source/Documentation/usb/usbmon.rst)

usbmon 是内核自带的一个模块，可以收集usb总线上的数据。
usbmon也是tcpdump、usbdump、USBmon这些应用层的工具的功能之一。

### debugfs

嵌入式系统可能默认并不支持debugfs，也不会把usbmon编译进去。首先检查是否支持debugfs，内核是否开启了usbmon功能。

Step 1: 检查内核是否支持debugfs

> 内核版本 >= 3.11

	Kernel hacking -->
	    Compile-time checks and compiler options -->
	        Debug Filesystem

> 内核版本 < 3.11

	Kernel hacking -->
	    Debug Filesystem

在目标.config中检查

	CONFIG_DEBUG_FS=y

在目标机器上检查

root@q-K501LB:/# cat /proc/filesystems | grep debugfs
nodev   debugfs

再挂载debugfs

	mount -t debugfs none /sys/kernel/debug

Step 2: usbmon

menuconfig中

	Device Drivers -->
	    USB support -->
	        USB Monitor  (Built-in)

目标.config

	CONFIG_USB_MON=m

目标机器上

	/sys/kernel/debug/usb/usbmon/


Step 3：判断usb bus

确认模块在哪一条usb总线上，方法包括

	lsusb
	dmesg log
	cat /sys/kernel/debug/usb/devices

Step 4: 抓log

切换到 /sys/kernel/debug/usb/usbmon 目录下，有如下文件

	0s 0u 1s 1t 1u 2s 2t 2u 3s 3t 3u 4s 4t 4u

模块挂在哪个Bus上，譬如模组在Bus 3上，就

	cat 3u > /tmp/usbmon_log.txt

	0s 0u 1s 1t 1u 2s 2t 2u 3s 3t 3u 4s 4t 4u

1、2、3、4代表usb总线号，0代表所有的usb总线。模块连接在ubuntu的第3条usb总线上，因此 cat 3u 。

s、t、u表示输出的usbmon log的format，其中u输出的信息最详细，因此使用u结尾的文件。


### tcpdump -D usbmonX

cat /sys/kernel/debug/usb/usbmon 的方式抓包的时候，有个缺点，只能显示前40个字节。
要想抓全部的数据，可以用tcpdump来抓。
而且用tcpdump抓的数据，可以用wireshark工具来解析，wireshard能分析常用的协议，非常方便。

步骤如下:
- Step 1: 和前面一样，确认系统有usbmon驱动和 debugfs.

- Step 2: tcpdump D 可以显示可以抓包的设备
	
	
	root@q-K501LB$: tcpdump -D
	
	1.wlan0 [Up, Running]
	
	2.lo [Up, Running, Loopback]
	
	3.any (Pseudo-device that captures on all interfaces) [Up, Running]
	
	4.eth0 [Up]

	5.bluetooth-monitor (Bluetooth Linux Monitor) [none]
	
	6.nflog (Linux netfilter log (NFLOG) interface) [none]
	
	7.nfqueue (Linux netfilter queue (NFQUEUE) interface) [none]
	
	8.bluetooth0 (Bluetooth adapter number 0) [none]
	
	9.usbmon0 (Raw USB traffic, all USB buses) [none]
	
	10.usbmon1 (Raw USB traffic, bus number 1)

	11.usbmon2 (Raw USB traffic, bus number 2)
	
	12.wwan0 [none]


- Step 3: 抓包，并保存到数据到文件中

	# tcpdump -i usbmon1 -w usbmon.pcap &

- Step 4: Killall tcpdump，并用wireshard打开抓到的文件usbmon.pcap。 




:)
